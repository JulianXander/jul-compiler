?type inference: generic parameter im inferred return type bei function literal?
	?ArgumentReference in symbolTable ?was ist mit nested function calls und namenskonflikten
		?alternativ: functionRef bei symbols die function parameter sind, bei dereference symbol in functionLiteral mit gleicher functionRef ArgumentReference liefern

	?infer function call return type mit generic return type durch inferring der args typen und ersetzung der type parameter
	?stattdessen (oder zusätzlich): infer function call return type durch inferring des function return types in neuem scope mit inferten args types
	-vgl Without in core-lib.jul
	-vgl test1-wip.jul
	-vgl Stream in core-lib.jul, ArgumentReference in type-checker.ts
?type inference: infer pure function call return type wenn alle argumente statisch bekannt durch aufruf der funktion
	-vgl. type-checking-test.jul Zeile 50 vs 51 variable type
	?wie erkennt man dass ein argument statisch bekannt ist
	?pure functions kennzeichnen
		?wie
-typechecking testen:
	-Without
	-NonZeroInteger
-type inference: infer argument type bei function literal wenn literal inline argument eines function calls ist
	-vgl fizz-buzz.jul index
-type inference: infer branching argument type im sub scope der branch functions narrowed by function parameter type
	-fehler wenn branching argument type = empty/never, also unreachable code detected
-examples sortieren, aufräumen, organisieren?
-homepage
	?deutsch vs englisch
	-title navbar
		-home, roadmap, documentation
+infix function call chain inline/multiline
	-runtime testen
-float typeToString mit f?
?FractionValueType
	-für custom typeToSting
?typeToString mit custom types, custom toString?
-docs
	-https://prismjs.com/extending.html#language-definitions
-builtins:
	-Fraction
		-create Fraction mit denominator kürzen
			-auch in parser
		?toString
		?fractionToDecimal mit x Stellen
		?fractionToFloat mit x Stellen
		-number type
		-integer type
	-Intersection/Exclude
	-NonZero (Integer/Float?), PositiveInteger
	-repeat?
	-modulo
	-equal
	?Subtract type?
		-PositiveInteger.subtract(1) => PositiveInteger & 0 = NonNegativeInteger
		-(positiveInteger.exclude(1)).subtract(1) => (PositiveInteger & 0).exclude(1 - 1 = 0) = PositiveInteger
?function as type
	-1. check args assignable
	-2. check returnValue = true
?catchAll default case in branching mit () oder Any?
-fix infix (dotted) function call parser mit chains, vgl fizz-buzz.jul
-taschenrechner demo app
-fix and typeChecking vgl typeCheckingTest.jul
-tuple typechecking
?fix dictionary value als type typeChecking?
	?wie soll sich das verhalten? wird das gebraucht?
?typeChecking: return union mit Error, oder compiler error
	?compiler error wenn assignment unmöglich, error union type wenn Fehler möglich?
-file system guided intellisense bei import path
?dateiendung bei import path angeben
	?json, yaml, js, ts imports
-virtual document für core-lib.jul
	-https://code.visualstudio.com/api/extension-guides/virtual-documents
-emitter mit parseExpression statt checkedExpression, checkedExpression entfernen
-out js files bundlen statt node modules kopieren
	?npm module publishen?
?Decimal
	?decimal fixed precision? arbitrary precision?
	?Decimal: 123d, 12.3d vs d123, d12.3