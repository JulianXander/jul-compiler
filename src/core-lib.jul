true = nativeValue(§true§)
false = nativeValue(§false§)
#region Types
# TODO split Unknown Type?
# any value
Any = nativeValue(§_any§)
# true or false
Boolean = nativeValue(§_boolean§)
# 64 bit floating point number
Float64 = nativeValue(§_float64§)
# sequence of characters
String = nativeValue(§_string§)
Error = nativeValue(§_error§)
Dictionary = nativeFunction(
	(ElementType: Type): Type
	# TODO ???
	§x => typeof x === 'object'§
)
# data structure containing 1 or more elements of type ElementType
List = nativeFunction(
	(ElementType: Type): Type
	# TODO generic List check
	§Array.isArray§
)
# data structure representing a value of type T changing over time
Stream = nativeFunction(
	(ValueType: Type): Type
	# TODO generic Stream check
	§x => x instanceof Stream§
)
# Function = nativeFunction(
# 	# TODO?
# 	# (
# 	# 	parametersType: Type
# 	# 	returnType: Type
# 	# )
# 	§x => x instanceof Function§
# )

# Or(
# 	(...args: List(Any)): Boolean
# 	# Literals (Number, String, Boolean, Dictionary, List)
# 	# DictionaryType/DictionaryLiteralType/DictionaryTypeLiteral?
# 	FunctionType
# 	# TupleType?
# 	# StreamType?
# 	UnionType
# 	IntersectionType
# )
Type = nativeValue(§_type§)
# IntersectionType
And = nativeFunction(
	(...ChoiceTypes: List(Type)): Type
	§(...args) => new IntersectionType(args)§
)
# UnionType
Or = nativeFunction(
	(...ChoiceTypes: List(Type)): Type
	§(...args) => new UnionType(args)§
)
# The Type that only contains the given value.
TypeOf = nativeFunction(
	(value: Any): Type
	§value => new TypeOfType(value)§
)
# The set of values that is of the given Type
# The inverse of TypeOf
ValueOf = nativeFunction(
	(T: TypeOf(Any)): T/value
	§T => new ValueOfType(T)§
)
#endregion Types
#region Functions
#region Number
# minuend - subtrahend
subtract = nativeFunction(
	(minuend: Float64 subtrahend: Float64): Float64
	§(minuend, subtrahend) => minuend - subtrahend§
)
# Gibt die Summe der args zurück.
sum = nativeFunction(
	(...arg: List(Float64)): Float64
	§
		(...args) =>
			args.reduce(
				(accumulator, current) =>
					accumulator + current,
				0)
	§
)
#endregion Number
#region Stream
#region core
# Beendet den Stream.
complete = nativeFunction(
	(stream$: Stream(Any)): ()
	§
		(stream$) => {
			stream$.complete();
			return null;
		}
	§
)
subscribe = nativeFunction(
	(stream$: Stream(Any) listener: (value: stream$/ValueType): ()): ()
	§
		(stream$, listener) => {
			const listenerFunction = (value) => {
				_callFunction(listener, [value]);
			};
			return stream$.subscribe(listenerFunction);
		}
	§
)
#endregion core
#region create
# gibt alle delayMs die nächste Zahl aus, beginnend mit 1
timer$ = nativeFunction(
	(delayMs: Float64): Stream(Float64)
	§
		(delayMs) => {
			const stream$ = createSource$(1);
			const cycle = () => {
				setTimeout(() => {
					if (stream$.completed) {
						return;
					}
					processId++;
					stream$.push(stream$.lastValue! + 1, processId);
					cycle();
				}, delayMs);
			};
			cycle();
			return stream$;
		}
	§
)
#endregion create
#endregion Stream
#region Utility
import = nativeFunction(
	(path: String): Any
	§require§
)
# Gibt die args in der Konsole aus.
log = nativeFunction(
	(...args: List(Any)): ()
	§console.log§
)
# Führt den gegebenen String als JavaScript aus und liefert dessen Rückgabe.
runJS = nativeFunction(
	(js: String): Any
	§eval§
)
# Interpretes the given String as js Code and yields the return value,
# assuming the specified type without checking. Make sure the Type fits under all circumstances
nativeFunction = nativeFunction(
	# (FunctionType: (x: Any): x is (): Any js: String): FunctionType
	(FunctionType: Type js: String): ValueOf(FunctionType)
	§[...]§
)
# Interpretes the given String as js Code and yields the return value,
# type???
nativeValue = nativeFunction(
	(js: String): Any
	§[...]§
)
#endregion Utility
#endregion Functions
# Type = Any: Boolean
# FunctionType = (x: Any): x is (): Any